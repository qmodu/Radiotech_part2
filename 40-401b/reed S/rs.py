# -*- coding:utf-8 -*-

from ff import GF256int
from polynomial import Polynomial

"""Этот модуль реализует кодирование методом Рида-Соломона.
Он поддерживает произвольные конфигурации для n и k, где n - длина кодового слова, а 
k - длина сообщения. Это можно использовать для регулировки и коррекции ошибок, а также мощности
кода.

Предупреждение: Из-за того, как реализованы вещи, приводя нулевые байты в сообщение,
байты отбрасываются. Будьте осторожны при кодировании бинарных данных, разделите данные себе
для k байтов на блок, чтобы избежать проблем. Также смотрите опцию nostrip к
декодированию.

При вызове в качестве скрипа, этот файл кодирует данные из стандартого входа и выводит его
на стандартный вывод, используя стандартный код RS 255 223. Это подходит для
кодирования текста и вывода, но не пытаться кодировать двоичные данные с ним!

При кодировании, он выводит блоки 255 байт, 223 из них данных (проложенный
с ведущими нулевыми байтами в случае необходимости), а затем 32 байт данных четности.

Используйте флаг -d для декодирования данных на стандартных и стандартный вывод. Об этом говорится в
Блоки 255 байт, и выводит декодированные данные от них. Если есть меньше,
чем 16 ошибок в блоке, ваши данные будут восстановлены.
"""

class RSCoder(object):
    def __init__(self, n, k):
        """Создает новый объект Рида-Соломона кодер/декодер, с присваиваемыми
         значениями n и k где,
         n - длина кодового слова, должна быть меньше, чем 256
         k - длина сообщения, должна быть меньше, чем n

        Код будет иметь мощность корректировки ошибки S, где 2S = n - k
        """
        if n < 0 or k < 0:
            raise ValueError("n и k должны быть положительными")
        if not n < 256:
            raise ValueError("n должна быть не более 256")
        if not k < n:
            raise ValueError("Длина кодового слова n должна быть больше чем длина сообщения")
        self.n = n
        self.k = k

        # Генерируем образующий полином для RS кодера
        # g(x) = (x-α^1)(x-α^2)...(x-α^(n-k))
        # α is 3, a генерируется в GF(2^8)
        g = Polynomial((GF256int(1),))
        for alpha in xrange(1,n-k+1):
            p = Polynomial((GF256int(1), GF256int(3)**alpha))
            g = g * p
        self.g = g

        # h(x) = (x-α^(n-k+1))...(x-α^n)
        h = Polynomial((GF256int(1),))
        for alpha in xrange(n-k+1,n+1):
            p = Polynomial((GF256int(1), GF256int(3)**alpha))
            h = h * p
        self.h = h

        # g*h используется в проверке, и всегда x^n-1
        self.gtimesh = Polynomial(x255=GF256int(1), x0=GF256int(1))

    def encode(self, message, poly=False):
        """Кодирует данную строку кодировкой Рида-Соломона. Возвращает байт
         строка с сообщением k байт и n-k четности байтов в конце.

         Если сообщение меньше k байт, то предполагается, что необходимо дополнить в начале
         нулевыми байтами.

         Последовательность возвращает всегда n байт.

         Если poly не является ложным, возвращаем закодированный полиномиальный объект вместо
        многочлена и переводим обратно в строку (полезно для отладки)
        """
        n = self.n
        k = self.k

        if len(message)>k:
            raise ValueError("Длина сообщения не более %d. Длина сообщения %d" % (k,
                len(message)))

        # Кодирование сообщения в виде полинома:
        m = Polynomial(GF256int(ord(x)) for x in message)

        # Сдвиг полинома до n-k путем умножения на x^(n-k)
        mprime = m * Polynomial((GF256int(1),) + (GF256int(0),)*(n-k))

        # mprime = q*g + b для некоторого q
        # найдем b:
        b = mprime % self.g

        # Вычитаем b, имеем c = q*g
        c = mprime - b
        # Так как c кратен g, то он имеет n-k корней: α^1 тогда
        # α^(n-k)

        if poly:
            return c

        # Переведем полином обратно в строку 
        return "".join(chr(x) for x in c.coefficients).rjust(n, "\0")

    def verify(self, code):
        """Проверяем правильность кода путем теста кода в виде полинома
        код делим на g
        проверяем да/нет
        """
        n = self.n
        k = self.k
        h = self.h
        g = self.g

        c = Polynomial(GF256int(ord(x)) for x in code)

        # Это тоже работает, но занимает больше времени. Обе проверки подходят
        #возвращаем (c*h)%gtimesh == Polynomial(x0=0).

        # Поскольку кодовое слово кратно g, проверяем этот код деля на g
        #этого достаточно для проверки кодового слова.
        return c % g == Polynomial(x0=0)

    def decode(self, r, nostrip=False):
        """Принимаем полученную строку или массив байт r и пытаемся расшифровать.
        Если это действующее кодовое слово, или если не содержит более (n-k)/2 
        ошибок, сообщение возвращается.

        Сообщение всегда имеет k байт, если сообщение меньше то оно дополняется
        нулевыми байтами. При декодировании отделим эти ведущие нулевые байты
        но это может вывать проблемы при декодировании двоичных данных. Когда
        nostrip истина, сообщение всегда возвращает k байт. Это полезно
        и позволяет убедиться, что нету потерянных данных при декодировании.
        """
        n = self.n
        k = self.k

        if self.verify(r):
            # Последние n-k байты четности
            if nostrip:
                return r[:-(n-k)]
            else:
                return r[:-(n-k)].lstrip("\0")

        #### Возвращаем r в полином
        r = Polynomial(GF256int(ord(x)) for x in r)

        # Вычисляем синдромы:
        sz = self._syndromes(r)

        # Найдем полином описывающий положение ошибки и полином оценивающий 
        # ошибку используя алгоритм Берлекампа-Месси
        sigma, omega = self._berlekamp_massey(sz)

        # Now use Chien's procedure для нахождения позиции ошибки
        # j это массив целых чисел, представляющий позиции ошибок, 0
        # означает самый правый байт
        # X соответствует значению массива GF(2^8) значений,
        # где X_i = alpha^(j_i)
        X, j = self._chien_search(sigma)

        # Найдем велинины ошибок с помощью метода Форни
        # Y в массиве GF(2^8) это значение, соответствующей величины ошибки
        # с позицией заданной массивом j 
        Y = self._forney(omega, X)

        # Поставим ошибку и ее положение вместе, в полином ошибок
        Elist = []
        for i in xrange(255):
            if i in j:
                Elist.append(Y[j.index(i)])
            else:
                Elist.append(GF256int(0))
        E = Polynomial(reversed(Elist))

        # Получаем наше кодовое слово
        c = r - E

        # Формируем его обратно в строку и возвращаем все последние n-k байт
        ret = "".join(chr(x) for x in c.coefficients[:-(n-k)])

        if nostrip:
            # Полиномиальные объекты не хранят ведущие нулевые коэффициенты,
            # поэтому мы на самом деле должны дополнить это до k байт
            return ret.rjust(k, "\0")
        else:
            return ret


    def _syndromes(self, r):
        """С учетом принятого кодового слова r в виде полиномиального объекта,
        вычисляет синдромы и возвращает синдромы в полином
        """
        n = self.n
        k = self.k

        # s[l] принятое кодовое слово оценивается α^l при 1 <= l <= s
        # α здесь равен 3
        s = [GF256int(0)] # s[0] равен 0 (коэффициент z^0)
        for l in xrange(1, n-k+1):
            s.append( r.evaluate( GF256int(3)**l ) )

        # Теперь стоим многочлен из всех наших s[l] значений
        # s(z) = sum(s_i * z^i, i=1..inf)
        sz = Polynomial( reversed( s ) )

        return sz

    def _berlekamp_massey(self, s):
        """Вычисляет и возвращает в полином описывающий положение ошибки (sigma)
        и в полином оценивающий ошибку (omega)
        Параметр s является синдромом многочлена (синдром кодируется в
        функциональном генераторе) который возвращает _синдромов. Не путать с 
        другим s = (n-k)/2

        Примечания:
        Полином описывающий ошибку:
        E(x) = E_0 + E_1 x + ... + E_(n-1) x^(n-1)

        j_1, j_2, ..., j_s позиция ошибки. (Есть в большинсвте s
        ошибках)

        Положение ошибки X_i определяется: X_i = α^(j_i)
        то есть, мощность α соответствующая положению ошибки

        Величина ошибки Y_i определяется: E_(j_i)
        то есть, коэффициент в полиноме описывающем ошибку j_i

        Полином описывающий положение ошибки:
        sigma(z) = Product( 1 - X_i * z, i=1..s )
        корни обратные местам ошибок
        ( 1/X_1, 1/X_2, ...)

         полином оценивающий ошибку omega(z) здесь не описывается
        """
        n = self.n
        k = self.k

        # Инициализация:
        sigma =  [ Polynomial((GF256int(1),)) ]
        omega =  [ Polynomial((GF256int(1),)) ]
        tao =    [ Polynomial((GF256int(1),)) ]
        gamma =  [ Polynomial((GF256int(0),)) ]
        D =      [ 0 ]
        B =      [ 0 ]

        # Константы:
        ONE = Polynomial(z0=GF256int(1))
        ZERO = Polynomial(z0=GF256int(0))
        Z = Polynomial(z1=GF256int(1))
        
        # Итеративно вычисляем полиномы до 2s раз.
        # Последний из них будет правильными.
        for l in xrange(0, n-k):
            # Цель для каждой итерации: вычисляем sigma[l+1] и omega[l+1] что
            # (1 + s)*sigma[l] == omega[l] в mod z^(l+1)

            # Для этой конкретной итерации, мы имеем sigma[l] и omega[l],
            # и вычисления sigma[l+1] и omega[l+1]
            
            # Первым находим Delta, с ненулевыми коэффицентами z^(l+1) в
            # (1 + s) * sigma[l]
            # Эта Delta действительна для l (в этой итерации) только
            Delta = ( (ONE + s) * sigma[l] ).get_coefficient(l+1)
            # Делаем этот полином в степени 0
            Delta = Polynomial(x0=Delta)

            # Теперь можем вычислить sigma[l+1] и omega[l+1] для
            # sigma[l], omega[l], tao[l], gamma[l], и Delta
            sigma.append( sigma[l] - Delta * Z * tao[l] )
            omega.append( omega[l] - Delta * Z * gamma[l] )

            # Далее вычисляем tao и gamma
            # Есть два способа сделать это
            if Delta == ZERO or 2*D[l] > (l+1):
                # Сбособ 1
                D.append( D[l] )
                B.append( B[l] )
                tao.append( Z * tao[l] )
                gamma.append( Z * gamma[l] )

            elif Delta != ZERO and 2*D[l] < (l+1):
                # Способ 2
                D.append( l + 1 - D[l] )
                B.append( 1 - B[l] )
                tao.append( sigma[l] // Delta )
                gamma.append( omega[l] // Delta )
            elif 2*D[l] == (l+1):
                if B[l] == 0:
                    # Способ 1 (как указанно выше)
                    D.append( D[l] )
                    B.append( B[l] )
                    tao.append( Z * tao[l] )
                    gamma.append( Z * gamma[l] )

                else:
                    # Способ 2 (как указанно выше)
                    D.append( l + 1 - D[l] )
                    B.append( 1 - B[l] )
                    tao.append( sigma[l] // Delta )
                    gamma.append( omega[l] // Delta )
            else:
                raise Exception("Код не должен быть получен здесь")


        return sigma[-1], omega[-1]

    def _chien_search(self, sigma):
        """Напомним определение sigma , она имеет s корней. Для их нахождения, эта
        функция оценивает sigma на всех 255 ненулевых точках чтобы найти корни
        Обратные корни X_i, это места ошибок.

        Возвращает список X места ошибок, и соответствующий список j 
        позиции ошибок(дескретная журнала соответствует значению X).
        Списки заполняются до s элемента.

        Важно техническая математика примечание: эта реализация на самом деле
        не поиск члена. Поиск члена это такой способ оценить полином
        что каждая оценка делается только в определенное время. Здесь просто
        делается 255 оценок, что гораздо менее эффективно.
        """
        X = []
        j = []
        p = GF256int(3)
        for l in xrange(1,256):
            # Эти оценки могут быть более эффективными
            if sigma.evaluate( p**l ) == 0:
                X.append( p**(-l) )
                j.append(255 - l)

        return X, j

    def _forney(self, omega, X):
        """Вычисляем величины ошибок"""
        
        s = (self.n - self.k) // 2

        Y = []

        for l, Xl in enumerate(X):
            # Вычисляем первую часть Yl
            Yl = Xl**s
            Yl *= omega.evaluate( Xl.inverse() )
            Yl *= Xl.inverse()

            # Вычисляем произведение последовательности и и производим обратное умножение
            prod = GF256int(1)
            for ji in xrange(s):
                if ji == l:
                    continue
                if ji < len(X):
                    Xj = X[ji]
                else:
                    Xj = GF256int(0)
                prod = prod * (Xl - Xj)
            Yl = Yl * prod.inverse()

            Y.append(Yl)
        return Y

if __name__ == "__main__":
    import sys
    coder = RSCoder(255,223)
    if "-d" in sys.argv:
        method = coder.decode
        blocksize = 255
    else:
        method = coder.encode
        blocksize = 223

    while True:
        block = sys.stdin.read(blocksize)
        if not block: break
        code = method(block)
        sys.stdout.write(code)
